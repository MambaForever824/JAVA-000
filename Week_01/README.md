类的生命周期
1、加载（Loading）: 找Class文件；
2、验证（Verification）: 验证格式、依赖；
3、准备（Preparation）: 静态字段、方法表；
4、解析（Resolution）: 符号解析为引用；
5、初始化（Initialization）: 构造器、静态变量赋值、静态代码块；
6、使用（Using）；
7、卸载（Unloading）；
其中：
1-5 步 为 类的【加载】过程
2-4 步 为 类的【链接（Linking）】

类的加载时机
1、When: 虚拟机启动时，Do: 初始化用户指定的主类，就是启动执行的【main方法】所在的类；
2、When: 当遇到用以新建目标类实例的【new指令】时，Do: 初始化【new指令】的【目标类】，就是【new一个类】的时候需要初始化；
3、When: 当遇到【调用静态方法的指令】时，Do: 初始化该【静态方法所在的类】；
4、When: 当遇到【访问静态字段的指令】时，Do: 初始化该【静态方法所在的类】；
5、子类的初始化会触发父类的初始化；
6、如果一个接口定义了default方法，直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7、使用反射API对某个类进行【反射调用】时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；
8、当初次调用【MethodHandle】实例时，初始化该【MethodHandle】执行的方法所在的类；

不会初始化（可能会加载）
1、通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；
2、定义对象数组，不会触发该类的初始化；
3、常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类；
4、通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始化；
5、通过 Class.forName 加载知道类时，如果指定参数 initialize为 false 时，也不会触发类初始化，其实这个参数告诉虚拟机，是否要对类进行初始化。
6、通过 CLassLoader 默认的 loadClass 方法，也不会触发初始化动作（仅加载）；

类加载器
1、启动类加载器 (Bootstrap ClassLoader)
2、扩展类加载器 (ExtClassLoader)
3、应用类加载器 (AppClassLoader)
对同一个类加载器，一个类只会被加载一次